
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="txt/html">
  <title>CMPS 321 - Lab 8</title>
</head>

<body>
<h2>Lab 8 - Loop Unrolling</h2>
Due: Wednesday at noon
<p>
The purpose of this lab is to study loop unrolling for both the normal
pipelined datapath (1 instruction issued per cycle) and the static 
multiple-issue datapath (2 instructions issued per cycle).
<p>
Loop unrolling can be used for both the normal pipelined datapath and the
static multiple-issue datapath. When used for the normal pipelined datapath,
the goal is to make the code as fast as possible by avoiding as many stalls
as possible. By unrolling the loop, there is more potential for reordering
the instructions to avoid stalls after load word and there are fewer 
instances of the loop test branch instruction. When used for the static
multiple-issue datapath, the goal is to avoid as many nop instructions as
possible and to minimize the number of cycles needed to complete the loop.
<p>
So far, we have only looked at post-test (e.g. do-while) loops for loop 
reordering and unrolling (this was the style of loops used in both Monday's 
lecture and the book). In this lab, we'll look at unrolling a pre-test (e.g.
a for or while) loop. For purposes of this lab, assume the
branch and jump are resolved in the ID stage. Also assume that there is no 
branch prediction, so we have to stall one cycle after a branch in order to 
resolve it.
<p>
Here is the original loop:
<pre>
Loop:  beq  $s0, $s1, Exit
       lw   $t0, 0($s0)
       add  $s2, $s2, $t0
       addi $t0, $t0, -5
       sw   $t0, 0($s0)
       addi $s0, $s0, 4
       j    Loop
Exit:
</pre>

Answer the following questions. When answering, assume that we have data 
forwarding available and that branches resolve in the ID stage.
<ol>
<li>Show the original pipeline (one instruction per cycle) for two iterations of this loop with NO loop
    unrolling and NO reordering on the normal pipeline. Your response should 
    be a diagram similar to the solution for HW 4 which shows all the stalls 
    (including those caused by the branch and jump).
<li>Unroll the loop once so it contains two iterations. Reorder the code to
    minimize the number of stalls for the normal pipeline (one instruction per cycle). Show the code once
    it has been unrolled and reordered.
<li>Show the pipeline for the code in Question 2 on the normal pipeline (one instruction per cycle). 
    (Note: This is the "fast execution on the MIPS pipeline" schedule that
    HW 6 Question 1 asks for)
<li>Show the schedule for the static multiple-issue pipeline (two instructions per cycle) that uses the
    unrolled code in Question 2. You may do further reordering to support the
    multiple-issue pipeline in your response. Clearly indicate the full 
    instruction scheduled in each issue slot if you do reorder for this
    schedule.
</ol>

Upload your answers to Moodle in plain text, PDF or OpenOffice format if using
a document program or one of the supported image formats if using a scan of a
hard copy answer.
</body>
</html>
