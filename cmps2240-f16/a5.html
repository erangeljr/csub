<!DOCTYPE html>
<html>
<body>
<link rel="stylesheet" href="./cssReset.css">
<style>
	a:link    {color:#751;} /* unvisited link */
	a:visited {color:#e74;} /* visited link */
	a:hover   {color:#000;background:#ec9;} /* mouse over link */
	a:active  {color:#0b0;} /* selected link */
	body {
		margin: 2% 5% 5% 5%;
		font-family: serif;
		background-color: #ffd;
		color: #19193A;
		font-weight: normal;
		font-size: 11pt;
		line-height:normal;
	}
	div {
		margin: 3px;
		padding: 4px;
		border: 1px dashed black;
		font-family: serif;
		font-size: 11pt;
		font-weight: 500;
		color: #000;
		background: #bdf;
		padding-right: 20px;
		height: auto;
		height: 60px;
	}
	.notes {
		background-color:papayawhip;
		width:250px;
		height:110px;
	}
	ul.a {
		list-style-type:circle;
		margin-left:26px;
		line-height:150%;
		/*color:#000000;*/
	}
	ul.b {
		list-style-type:disc;
		margin-left:26px;
		line-height:100%;
		/*color:#000000;*/
		color:#664422;
	}
	b { font-weight: 900; }
	code { font-family: monospace; }
	pre { font-family: monospace; font-size: 10pt; }
	input { background:#ed8; }
	h3 {
		font-size: 12pt;
		font-weight: 600;
		font-family: serif;
		padding-top: 4px;
		padding-bottom: 6px;
	}
	sup {
	    vertical-align: super;
	    font-size: smaller;
	}
</style>
<script type="text/javascript">
	//used to toggle hints on/off
	var xb = [0];
	for (var i=0; i<200; i++) xb[i] = 1;
	function zzz(doc, text) {
		document.getElementById(doc).innerHTML=text; 
	}
</script>
<body>

<h3>CMPS-224 Homework #5: Bitwise Logic </h3>
This homework covers MIPS bit manipulation facilities in depth.<br> 
All answers are in the MIPS Tutorial 11 - 12.<br>
Answer the questions as you work through the tutorial.
<br>
<div class="notes" style="width:260px; height:70px">
Read completely:<br>
<ul class="a">
	<li><a href="http://chortle.ccsu.edu/AssemblyTutorial/Chapter-11/
		ass11_1.html">MIPS Tutorial Ch 11</a></li> 
	<li><a href="http://chortle.ccsu.edu/AssemblyTutorial/Chapter-12/
		ass12_1.html">MIPS Tutorial Ch 12</a></li> 
</ul>
</div>
<div class="notes" style="width:340px;">
Use as needed:<br>
<ul class="a">
	<li><a href="./doc/mips-quick-guide.txt">
		MIPS Quick Guide</a></li>
	<li><a href="./units_of_measure.html">
		CMPS Units of Measure</a></li> 
	<li><a href="./doc/HP_AppenA.pdf">
		Appendix A.10</a></li>
	<li><a href="./doc/mips32-instruc-set.pdf">
		MIPS32 Instruction Set Quick Reference</a></li>
</ul>
</div>
<br>


1. Where is the operand 0x2 placed in the binary encoding of this instruction?
<pre>

        ori $8, $0, 0x2
</pre>
<input type="button"value="hint"onClick="xb[ 1]^=1; zzz('x1', (xb[ 1])?'':
'This is a bitwise immediate OR between 0x2 and the contents of register 0. \
Since $0 contains zero, the result is 0x2 and is loaded into $8. \
The immediate operand 0x2 (hex 2) is loaded \
into the last 16 bits of the instruction. This means that immediate \
instructions are limited to 16-bit operands. ori with zero is a move operation'
);"><div id="x1"></div><br>


2. All MIPS registers are 32-bits. That means that $0 is a bit string of
   32 zeros. The operand in this bitwise immediate OR is only 16 bits. 
   How does MIPS handle this?
<pre>
           ori $8, $0, 0x2
</pre>
<input type="button"value="hint"onClick="xb[ 2]^=1; zzz('x2', (xb[ 2])?'':
'MIPS zero extends the 16-bit operand 0x2 by 16 bits. In other words, 0x2 is \
padded with zeros on the left to make it 32 bits.'
);"><div id="x2"></div><br>


3. Explain this MIPS instruction and give the result.<pre>
           ori $8, $0, 0x2 </pre>
<input type="button"value="hint"onClick="xb[ 3]^=1; zzz('x3', (xb[ 3])?'':
'The 16-bit 0x2 immediate operand has been zero-extended \
and loaded into register $8; i.e., positive decimal two is in $8. This \
is a very inexpensive way to load a register with a positive integer. You \
cannot load a negative integer, however. '
);"><div id="x3"></div><br>


4. Can you use ori to load a register with a signed integer? 
<input type="button"value="hint"onClick="xb[ 4]^=1; zzz('x4', (xb[ 4])?'':
'No. A signed integer has a sign bit in the most significant bit location. \
Since ori zero-extends the 16-bits to 32 bits, you can never have a 1 in the \
sign bit to represent a negative integer.  '
);"><div id="x4"></div><br>


5. What is wrong with the following instruction?
<pre>
        ori  $0, $9, 0x32
</pre>
<input type="button"value="hint"onClick="xb[ 5]^=1; zzz('x5', (xb[ 5])?'':
'You are trying to load register $0 with hex 32. $0 is zero and cannot \
be changed. You may not get an error if you do this but $0 remains zero.'
);"><div id="x5"></div><br>


6. What is loaded into $10 when you execute this code?
<pre>
    ## Program to bitwise OR two patterns 
   .text
   .globl  main
main:
    ori   $8,$0,0x0DA5    # put first pattern into register $8
    ori   $10,$8,0x368F   # or ($8) with second pattern.  Result to $10.
## End of file
</pre>
<input type="button"value="hint"onClick="xb[ 6]^=1; zzz('x6', (xb[ 6])?'':
'<pre>\
    0000 1101 1010 0101   0DA5  <br>\
 |  0011 0110 1000 1111   368F  <br>\
    --------------------  ----- <br>\
    0011 1111 1010 1111   3FAF      \
</pre>'
);"><div id="x6"style="height:80px"></div><br>


7. Explain in detail what this instruction does and give the result.
<pre>
         andi $8, $0, 0xFFFF
</pre>
<input type="button"value="hint"onClick="xb[ 7]^=1; zzz('x7', (xb[ 7])?'':
'This is  MIPS bitwise immediate and. The constant 0xffff  is zero extended \
to 32 bits to the left. A bitwise AND is performed with 0xffff and 32 \
zeros. The result is a 32 bit string of zeros. This is a quick way \
to clear a register (filling a register with all zero bits).'
);"><div id="x7"></div><br>


8. What is in $8, $9, and $10 after this program executes? Test in spim:
<pre>
 spim> re "q8.s" 
 spim> breakp main
 spim> run
 spim> s 
 spim> p $8  
 spim> s 
 spim> p $9
 spim> s 
 spim> p $10 

# file: q8.s
        .text
        .globl  main
main:
        ori     $15, $0,0x0DA5       # load bit pattern register into $15
        ori      $8,$15,0x368F       # OR with second pattern
        andi     $9,$15,0x368F       # AND with second pattern
        xori    $10,$15,0x368F       # XOR with second pattern
## End of file
</pre>
<input type="button"value="hint"onClick="xb[ 8]^=1; zzz('x8', (xb[ 8])?'':
'<pre><tt>\
$15 = 0000 1101 1010 0101  <br>\
   OR 0011 0110 1000 1111  <br>\
      -------------------- <br>\
$8 =  0011 1111 1010 1111  <br>\
        3   F    A    F    <br>\
                           <br>\
$15 = 0000 1101 1010 0101  <br>\
  AND 0011 0110 1000 1111  <br>\
      -------------------- <br>\
$9    0000 0100 1000 0101  <br>\
         0   4   8    5    <br>\
                           <br>\
$15 = 0000 1101 1010 0101  <br>\
  XOR 0011 0110 1000 1111  <br>\
      -------------------- <br>\
$10=  0011 1011 0010 1010  <br>\
         3    B    2    A\
</pre>'
);"><div id="x8"style="height:300px"></div><br>


9. Let b1 and b2 be loaded as shown below. What is in b1 after these C xor 
    operations? Is there a generalization you can make for any arbitrary
    bit string?
<pre>
    // load b1 with 1011
    a) b1 = b1 ^ b1;  // caret in C is bitwise exclusive or

    // load b1 with 1010 and b2 with 1001
    b) b1 = b1 ^ b2;  
       b2 = b2 ^ b1; 
       b1 = b1 ^ b2;
</pre>
<input type="button"value="hint"onClick="xb[ 9]^=1; zzz('x9', (xb[ 9])?'':
'<pre><tt>a) any bit string bitwise xor-ed with itself is all zeros<br>\
b) b2        <br>\
Let b1=1010. <br>\
Let b2=1001. (length 4 tests all possible outcomes) <br>\
        1010      1001      0011   <br>\
      ^ 1001    ^ 0011    ^ 1010   <br>\
        -----     -----     -----  <br>\
   b1:  0011  b2: 1010  b1: 1001. </pre><br>\
Note that b1 and b2 are swapped. XOR can be used to swap two \
arbitrary bit strings without using temp storage)\
</tt></pre>'
);"><div id="x9"style="height:200px"></div><br>


<hr>
<h5>Starting Tutorial 12</h5>
<hr>

10. What is the outcome of these MIPS instructions?
<pre>
      ori  $9,  $0, 0x5 
      sll  $10, $9, 3
</pre>     
<input type="button"value="hint"onClick="xb[10]^=1; zzz('x10',(xb[10])?'':
'Positive 5 is loaded into $9. 5 is shift left-ed by 3 which means 5 is \
multiplied by 2^3 (8). 0x28 (40 decimal) is loaded into $10. Thus \
5 * 8 is performed as it should be.'
);"><div id="x10"></div><br>


11. What is the value in $10 after you perform the sll operation below? $9 
    contains the 32-bit negative integer -5 stored in two's complement. When
    can using a shift left logical be a problem?
<pre>
        add  $9, $0, -5   # sign extend from 16 bit immediate to 32 neg int
        sll $10, $9, 2
</pre>
<input type="button"value="hint"onClick="xb[11]^=1; zzz('x11',(xb[11])?'':
'The result in Reg 10 is 0xffffffec (-20) as you would hope. Shifting a \
small negative integer to the left a few bits \
maintains the sign bit so this is equivalent to \
multiplying the negative integer by 2^2.\
Using a sll to multiply is a problem on a large unsigned positive int if you \
shift it by enough bits to flip it negative; i.e., if you shift a 1 \
into the sign bit.'
);"><div id="x11"style="height:80px"></div><br>


12. Sometimes you want to use the same register in an instruction. Is this OK?
<pre>
       ori   $8, $0, 0x6f
       sll   $8, $8, 2
</pre> 
<input type="button"value="hint"onClick="xb[12]^=1; zzz('x12',(xb[12])?'':
'Yes. Not a problem - often the safest and easist way to do it.'
);"><div id="x12"></div><br>


13. What does this instruction do?
<pre>
         sll $0, $0, 0
</pre>
<input type="button"value="hint"onClick="xb[13]^=1; zzz('x13',(xb[13])?'':
'Nothing, according to most assembly documentation and standards.<br>\
Shift some zero bits left by zero places, and store it in a register that is \
not allowed to be anything but zero.<br>\
Since the opcode for sll is 000000, the encoding for this instruction happens \
to be 0x00000000 (a 32 bit string of all zeros).'
);"><div id="x13"style="height:80px"></div><br>


14. What is the machine instruction in #13 called?
<input type="button"value="hint"onClick="xb[14]^=1; zzz('x14',(xb[14])?'':
'A no-op.<br>\
Just to be clear, there is plenty of activity going on in the processor to \
execute this instruction, but the net result is considered to be that nothing \
happened. The instruction above can be used as a nop, or no-operation \
instruction.'
);"><div id="x14"></div><br>


15. What is the result of the following shift right logical?
<pre>
        li   $9, -10
        srl  $10, $9, 2
</pre> 
<input type="button"value="hint"onClick="xb[15]^=1; zzz('x15',(xb[15])?'':
'Not what you would hope (-5). The problem is the sign bit. When you shift \
right you pad the empty bits on the left with zeros. This means the most \
significant byte in -10 (1111 1111) becomes (0011 1111). This is 3F. Running \
the code in spim confirms this:   <br>\
Reg 9 = 0xfffffff6 (-10)          <br>\
Reg 10 = 0x3ffffffd (1073741821). <br>\
Shift right on a small negative integer gives you a very large postive int!'
);"><div id="x15"style="height:120px"></div><br>


16. Assume a 32-bit register. If you shift left logical a value in that 
    register by 2 and then shift right logical on the result by 2
    do you always end up with the original pattern?
<input type="button"value="hint"onClick="xb[16]^=1; zzz('x16',(xb[16])?'':
'Not always. If there is a 1 in the leftmost bit (the sign bit), it will be \
lost when you shift left by 2. When you shift right it will not be \
recovered. If, on the other hand, the sign bit holds 0 then you can shift \
left by 1 and shift right by 1 and end up with the original value.'
);"><div id="x16"></div><br>


17. What is the difference between bitwise 'ORI' and bitwise 'OR' operators?
<input type="button"value="hint"onClick="xb[17]^=1; zzz('x17',(xb[17])?'':
'They are similar in some ways.<br>\
Please express the difference in your own words for me.'
);"><div id="x17"></div><br>


18. MIPS has a bitwise nor instruction (there is no immediate nor).   The
    meaning of nor is
<pre>
               nor
          -+--+---
          1| 1| 0
          -+--+---
          1| 0| 0
          -+--+---
          0| 1| 0
          -+--+---
          0| 0| 1
</pre> 
In other words, nor is 1  only when both operand bits are 0. What is
the bitwise NOR of the following?
<pre>
    FEED     
    BECA     
    -----    
</pre>
<input type="button"value="hint"onClick="xb[18]^=1; zzz('x18',(xb[18])?'':
'<pre> \
Please work this out.<br>\
                               FEED      1111 1110 1110 1101 <br>\
                               BECA      1011 1110 1100 1010 <br>\
                               ----      ------------------- <br>\
answer goes right there------>\
</pre>'
);"><div id="x18"style="height:80px"></div><br>


19. What is the result of this instruction?
<pre>
      li   $9, 1
      nor  $10,$9,$0
</pre>
<input type="button"value="hint"onClick="xb[19]^=1; zzz('x19',(xb[19])?'':
'Reg 10 = 0xfffffffe (if you treat this as a signed int it is -2)<br>\
Reg 9 = 0x00000001 (1)<br>\
As you might expect, this operation is a bitwise NOT; i.e., all the bits are \
flipped. The least significant byte does this: 0001 (1) becomes 1110 (e)'
);"><div id="x19"style="height:80px"></div><br>


20. Explain each of these bitwise ops. What does this code accomplish?
<pre>
    1    or  $9, $0, $0
    2    ori $8, $9, 0x001A
    3    or  $10, $8, $0
</pre>
<input type="button"value="hint"onClick="xb[20]^=1; zzz('x20',(xb[20])?'':
'Explain each operation please.<br>\
<br>\
<br>\
<br>\
These three operations taken together accomplish a simple task. What is it?'
);"><div id="x20"style="height:100px"></div><br>
<br>
<br>
<br>
<br>
<br>
<br>

<!--
<input type="button"value="hint"onClick="xb[21]^=1; zzz('x21',(xb[21])?'':
);"><div id="x21"></div><br>
<input type="button"value="hint"onClick="xb[22]^=1; zzz('x22',(xb[22])?'':
);"><div id="x22"></div><br>
-->



<hr>
</body>
</html>
