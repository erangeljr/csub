

Terminals which are not used:

   SCONST
   LBRACK
   RBRACK
   PLUSEQ
   MINUSEQ
   ERROR


State 17 contains 5 reduce/reduce conflicts.
State 41 contains 1 shift/reduce conflict.
State 44 contains 5 reduce/reduce conflicts.
State 64 contains 1 shift/reduce conflict.

Grammar
rule 1    @1 ->		/* empty */
rule 2    program -> number @1 decl_seq func
rule 3    decl_seq ->		/* empty */
rule 4    decl_seq -> decl_seq decl
rule 5    decl -> type_spec IDENT SEMI
rule 6    decl -> type_spec IDENT ASSIGN expr SEMI
rule 7    type_spec -> INT
rule 8    type_spec -> FLOAT
rule 9    type_spec -> CHAR
rule 10   @2 ->		/* empty */
rule 11   @3 ->		/* empty */
rule 12   @4 ->		/* empty */
rule 13   @5 ->		/* empty */
rule 14   func -> type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY
rule 15   param_list ->		/* empty */
rule 16   param_list -> param_seq
rule 17   param_seq -> param
rule 18   param_seq -> param COMMA param_seq
rule 19   param -> type_spec IDENT
rule 20   block -> LCURLY stmt_seq RCURLY
rule 21   block -> error
rule 22   stmt_seq ->		/* empty */
rule 23   stmt_seq -> stmt_seq stmt
rule 24   stmt_seq -> error
rule 25   stmt -> SEMI
rule 26   stmt -> expr SEMI
rule 27   stmt -> assign_stmt
rule 28   stmt -> WHILE condition block
rule 29   stmt -> IF condition block ELSE block
rule 30   stmt -> error
rule 31   assign_stmt -> IDENT ASSIGN expr SEMI
rule 32   condition -> LPAREN bool_expr RPAREN
rule 33   bool_expr -> term bool_op term
rule 34   bool_op -> EQ
rule 35   bool_op -> LE
rule 36   bool_op -> LT
rule 37   bool_op -> GT
rule 38   bool_op -> GE
rule 39   bool_op -> NE
rule 40   expr -> expr op term
rule 41   expr -> term
rule 42   expr -> error
rule 43   op -> TIMES
rule 44   op -> PLUS
rule 45   op -> MINUS
rule 46   op -> OVER
rule 47   term -> number
rule 48   term -> IDENT
rule 49   term -> CCONST
rule 50   number -> ICONST
rule 51   number -> FCONST
rule 52   number -> error

Terminals, with rules where they appear

$ (-1)
error (256) 21 24 30 42 52
IDENT (258) 5 6 14 19 31 48
ICONST (259) 50
FCONST (260) 51
CCONST (261) 49
SCONST (262)
INT (263) 7
FLOAT (264) 8
CHAR (265) 9
RET (266) 14
WHILE (267) 28
IF (268) 29
ELSE (269) 29
LPAREN (270) 14 32
RPAREN (271) 14 32
SEMI (272) 5 6 14 25 26 31
COMMA (273) 18
LBRACK (274)
RBRACK (275)
LCURLY (276) 14 20
RCURLY (277) 14 20
ASSIGN (278) 6 31
EQ (279) 34
LT (280) 36
LE (281) 35
GE (282) 38
GT (283) 37
NE (284) 39
PLUS (285) 44
MINUS (286) 45
TIMES (287) 43
OVER (288) 46
PLUSEQ (289)
MINUSEQ (290)
ERROR (291)

Nonterminals, with rules where they appear

program (37)
    on left: 2
@1 (38)
    on left: 1, on right: 2
decl_seq (39)
    on left: 3 4, on right: 2 4
decl (40)
    on left: 5 6, on right: 4
type_spec (41)
    on left: 7 8 9, on right: 5 6 14 19
func (42)
    on left: 14, on right: 2
@2 (43)
    on left: 10, on right: 14
@3 (44)
    on left: 11, on right: 14
@4 (45)
    on left: 12, on right: 14
@5 (46)
    on left: 13, on right: 14
param_list (47)
    on left: 15 16, on right: 14
param_seq (48)
    on left: 17 18, on right: 16 18
param (49)
    on left: 19, on right: 17 18
block (50)
    on left: 20 21, on right: 28 29
stmt_seq (51)
    on left: 22 23 24, on right: 14 20 23
stmt (52)
    on left: 25 26 27 28 29 30, on right: 23
assign_stmt (53)
    on left: 31, on right: 27
condition (54)
    on left: 32, on right: 28 29
bool_expr (55)
    on left: 33, on right: 32
bool_op (56)
    on left: 34 35 36 37 38 39, on right: 33
expr (57)
    on left: 40 41 42, on right: 6 14 26 31 40
op (58)
    on left: 43 44 45 46, on right: 40
term (59)
    on left: 47 48 49, on right: 33 40 41
number (60)
    on left: 50 51 52, on right: 2 47


state 0

    error	shift, and go to state 1
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3

    program	go to state 83
    number	go to state 4



state 1

    number  ->  error .   (rule 52)

    $default	reduce using rule 52 (number)



state 2

    number  ->  ICONST .   (rule 50)

    $default	reduce using rule 50 (number)



state 3

    number  ->  FCONST .   (rule 51)

    $default	reduce using rule 51 (number)



state 4

    program  ->  number . @1 decl_seq func   (rule 2)

    $default	reduce using rule 1 (@1)

    @1  	go to state 5



state 5

    program  ->  number @1 . decl_seq func   (rule 2)

    $default	reduce using rule 3 (decl_seq)

    decl_seq	go to state 6



state 6

    program  ->  number @1 decl_seq . func   (rule 2)
    decl_seq  ->  decl_seq . decl   (rule 4)

    INT 	shift, and go to state 7
    FLOAT	shift, and go to state 8
    CHAR	shift, and go to state 9

    decl	go to state 10
    type_spec	go to state 11
    func	go to state 12



state 7

    type_spec  ->  INT .   (rule 7)

    $default	reduce using rule 7 (type_spec)



state 8

    type_spec  ->  FLOAT .   (rule 8)

    $default	reduce using rule 8 (type_spec)



state 9

    type_spec  ->  CHAR .   (rule 9)

    $default	reduce using rule 9 (type_spec)



state 10

    decl_seq  ->  decl_seq decl .   (rule 4)

    $default	reduce using rule 4 (decl_seq)



state 11

    decl  ->  type_spec . IDENT SEMI   (rule 5)
    decl  ->  type_spec . IDENT ASSIGN expr SEMI   (rule 6)
    func  ->  type_spec . IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    IDENT	shift, and go to state 13



state 12

    program  ->  number @1 decl_seq func .   (rule 2)

    $default	reduce using rule 2 (program)



state 13

    decl  ->  type_spec IDENT . SEMI   (rule 5)
    decl  ->  type_spec IDENT . ASSIGN expr SEMI   (rule 6)
    func  ->  type_spec IDENT . @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    SEMI	shift, and go to state 14
    ASSIGN	shift, and go to state 15

    $default	reduce using rule 10 (@2)

    @2  	go to state 16



state 14

    decl  ->  type_spec IDENT SEMI .   (rule 5)

    $default	reduce using rule 5 (decl)



state 15

    decl  ->  type_spec IDENT ASSIGN . expr SEMI   (rule 6)

    error	shift, and go to state 17
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    expr	go to state 20
    term	go to state 21
    number	go to state 22



state 16

    func  ->  type_spec IDENT @2 . LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    LPAREN	shift, and go to state 23



state 17

    expr  ->  error .   (rule 42)
    number  ->  error .   (rule 52)

    SEMI	reduce using rule 42 (expr)
    SEMI	[reduce using rule 52 (number)]
    PLUS	reduce using rule 42 (expr)
    PLUS	[reduce using rule 52 (number)]
    MINUS	reduce using rule 42 (expr)
    MINUS	[reduce using rule 52 (number)]
    $default	reduce using rule 42 (expr)



state 18

    term  ->  IDENT .   (rule 48)

    $default	reduce using rule 48 (term)



state 19

    term  ->  CCONST .   (rule 49)

    $default	reduce using rule 49 (term)



state 20

    decl  ->  type_spec IDENT ASSIGN expr . SEMI   (rule 6)
    expr  ->  expr . op term   (rule 40)

    SEMI	shift, and go to state 24
    PLUS	shift, and go to state 25
    MINUS	shift, and go to state 26
    TIMES	shift, and go to state 27
    OVER	shift, and go to state 28

    op  	go to state 29



state 21

    expr  ->  term .   (rule 41)

    $default	reduce using rule 41 (expr)



state 22

    term  ->  number .   (rule 47)

    $default	reduce using rule 47 (term)



state 23

    func  ->  type_spec IDENT @2 LPAREN . @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    $default	reduce using rule 11 (@3)

    @3  	go to state 30



state 24

    decl  ->  type_spec IDENT ASSIGN expr SEMI .   (rule 6)

    $default	reduce using rule 6 (decl)



state 25

    op  ->  PLUS .   (rule 44)

    $default	reduce using rule 44 (op)



state 26

    op  ->  MINUS .   (rule 45)

    $default	reduce using rule 45 (op)



state 27

    op  ->  TIMES .   (rule 43)

    $default	reduce using rule 43 (op)



state 28

    op  ->  OVER .   (rule 46)

    $default	reduce using rule 46 (op)



state 29

    expr  ->  expr op . term   (rule 40)

    error	shift, and go to state 1
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    term	go to state 31
    number	go to state 22



state 30

    func  ->  type_spec IDENT @2 LPAREN @3 . param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    INT 	shift, and go to state 7
    FLOAT	shift, and go to state 8
    CHAR	shift, and go to state 9

    $default	reduce using rule 15 (param_list)

    type_spec	go to state 32
    param_list	go to state 33
    param_seq	go to state 34
    param	go to state 35



state 31

    expr  ->  expr op term .   (rule 40)

    $default	reduce using rule 40 (expr)



state 32

    param  ->  type_spec . IDENT   (rule 19)

    IDENT	shift, and go to state 36



state 33

    func  ->  type_spec IDENT @2 LPAREN @3 param_list . RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    RPAREN	shift, and go to state 37



state 34

    param_list  ->  param_seq .   (rule 16)

    $default	reduce using rule 16 (param_list)



state 35

    param_seq  ->  param .   (rule 17)
    param_seq  ->  param . COMMA param_seq   (rule 18)

    COMMA	shift, and go to state 38

    $default	reduce using rule 17 (param_seq)



state 36

    param  ->  type_spec IDENT .   (rule 19)

    $default	reduce using rule 19 (param)



state 37

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN . @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    $default	reduce using rule 12 (@4)

    @4  	go to state 39



state 38

    param_seq  ->  param COMMA . param_seq   (rule 18)

    INT 	shift, and go to state 7
    FLOAT	shift, and go to state 8
    CHAR	shift, and go to state 9

    type_spec	go to state 32
    param_seq	go to state 40
    param	go to state 35



state 39

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 . LCURLY stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    LCURLY	shift, and go to state 41



state 40

    param_seq  ->  param COMMA param_seq .   (rule 18)

    $default	reduce using rule 18 (param_seq)



state 41

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY . stmt_seq RET expr @5 SEMI RCURLY   (rule 14)

    error	shift, and go to state 42

    error	[reduce using rule 22 (stmt_seq)]
    IDENT	reduce using rule 22 (stmt_seq)
    ICONST	reduce using rule 22 (stmt_seq)
    FCONST	reduce using rule 22 (stmt_seq)
    CCONST	reduce using rule 22 (stmt_seq)
    RET 	reduce using rule 22 (stmt_seq)
    WHILE	reduce using rule 22 (stmt_seq)
    IF  	reduce using rule 22 (stmt_seq)
    SEMI	reduce using rule 22 (stmt_seq)
    OVER	reduce using rule 22 (stmt_seq)
    MINUSEQ	reduce using rule 22 (stmt_seq)
    ERROR	reduce using rule 22 (stmt_seq)

    stmt_seq	go to state 43



state 42

    stmt_seq  ->  error .   (rule 24)

    $default	reduce using rule 24 (stmt_seq)



state 43

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq . RET expr @5 SEMI RCURLY   (rule 14)
    stmt_seq  ->  stmt_seq . stmt   (rule 23)

    error	shift, and go to state 44
    IDENT	shift, and go to state 45
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19
    RET 	shift, and go to state 46
    WHILE	shift, and go to state 47
    IF  	shift, and go to state 48
    SEMI	shift, and go to state 49

    stmt	go to state 50
    assign_stmt	go to state 51
    expr	go to state 52
    term	go to state 21
    number	go to state 22



state 44

    stmt  ->  error .   (rule 30)
    expr  ->  error .   (rule 42)
    number  ->  error .   (rule 52)

    SEMI	reduce using rule 30 (stmt)
    SEMI	[reduce using rule 42 (expr)]
    SEMI	[reduce using rule 52 (number)]
    PLUS	reduce using rule 42 (expr)
    PLUS	[reduce using rule 52 (number)]
    MINUS	reduce using rule 42 (expr)
    MINUS	[reduce using rule 52 (number)]
    $default	reduce using rule 30 (stmt)



state 45

    assign_stmt  ->  IDENT . ASSIGN expr SEMI   (rule 31)
    term  ->  IDENT .   (rule 48)

    ASSIGN	shift, and go to state 53

    $default	reduce using rule 48 (term)



state 46

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET . expr @5 SEMI RCURLY   (rule 14)

    error	shift, and go to state 17
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    expr	go to state 54
    term	go to state 21
    number	go to state 22



state 47

    stmt  ->  WHILE . condition block   (rule 28)

    LPAREN	shift, and go to state 55

    condition	go to state 56



state 48

    stmt  ->  IF . condition block ELSE block   (rule 29)

    LPAREN	shift, and go to state 55

    condition	go to state 57



state 49

    stmt  ->  SEMI .   (rule 25)

    $default	reduce using rule 25 (stmt)



state 50

    stmt_seq  ->  stmt_seq stmt .   (rule 23)

    $default	reduce using rule 23 (stmt_seq)



state 51

    stmt  ->  assign_stmt .   (rule 27)

    $default	reduce using rule 27 (stmt)



state 52

    stmt  ->  expr . SEMI   (rule 26)
    expr  ->  expr . op term   (rule 40)

    SEMI	shift, and go to state 58
    PLUS	shift, and go to state 25
    MINUS	shift, and go to state 26
    TIMES	shift, and go to state 27
    OVER	shift, and go to state 28

    op  	go to state 29



state 53

    assign_stmt  ->  IDENT ASSIGN . expr SEMI   (rule 31)

    error	shift, and go to state 17
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    expr	go to state 59
    term	go to state 21
    number	go to state 22



state 54

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr . @5 SEMI RCURLY   (rule 14)
    expr  ->  expr . op term   (rule 40)

    PLUS	shift, and go to state 25
    MINUS	shift, and go to state 26
    TIMES	shift, and go to state 27
    OVER	shift, and go to state 28

    $default	reduce using rule 13 (@5)

    @5  	go to state 60
    op  	go to state 29



state 55

    condition  ->  LPAREN . bool_expr RPAREN   (rule 32)

    error	shift, and go to state 1
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    bool_expr	go to state 61
    term	go to state 62
    number	go to state 22



state 56

    stmt  ->  WHILE condition . block   (rule 28)

    error	shift, and go to state 63
    LCURLY	shift, and go to state 64

    block	go to state 65



state 57

    stmt  ->  IF condition . block ELSE block   (rule 29)

    error	shift, and go to state 63
    LCURLY	shift, and go to state 64

    block	go to state 66



state 58

    stmt  ->  expr SEMI .   (rule 26)

    $default	reduce using rule 26 (stmt)



state 59

    assign_stmt  ->  IDENT ASSIGN expr . SEMI   (rule 31)
    expr  ->  expr . op term   (rule 40)

    SEMI	shift, and go to state 67
    PLUS	shift, and go to state 25
    MINUS	shift, and go to state 26
    TIMES	shift, and go to state 27
    OVER	shift, and go to state 28

    op  	go to state 29



state 60

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 . SEMI RCURLY   (rule 14)

    SEMI	shift, and go to state 68



state 61

    condition  ->  LPAREN bool_expr . RPAREN   (rule 32)

    RPAREN	shift, and go to state 69



state 62

    bool_expr  ->  term . bool_op term   (rule 33)

    EQ  	shift, and go to state 70
    LT  	shift, and go to state 71
    LE  	shift, and go to state 72
    GE  	shift, and go to state 73
    GT  	shift, and go to state 74
    NE  	shift, and go to state 75

    bool_op	go to state 76



state 63

    block  ->  error .   (rule 21)

    $default	reduce using rule 21 (block)



state 64

    block  ->  LCURLY . stmt_seq RCURLY   (rule 20)

    error	shift, and go to state 42

    error	[reduce using rule 22 (stmt_seq)]
    IDENT	reduce using rule 22 (stmt_seq)
    ICONST	reduce using rule 22 (stmt_seq)
    FCONST	reduce using rule 22 (stmt_seq)
    CCONST	reduce using rule 22 (stmt_seq)
    WHILE	reduce using rule 22 (stmt_seq)
    IF  	reduce using rule 22 (stmt_seq)
    SEMI	reduce using rule 22 (stmt_seq)
    RCURLY	reduce using rule 22 (stmt_seq)
    OVER	reduce using rule 22 (stmt_seq)
    MINUSEQ	reduce using rule 22 (stmt_seq)
    ERROR	reduce using rule 22 (stmt_seq)

    stmt_seq	go to state 77



state 65

    stmt  ->  WHILE condition block .   (rule 28)

    $default	reduce using rule 28 (stmt)



state 66

    stmt  ->  IF condition block . ELSE block   (rule 29)

    ELSE	shift, and go to state 78



state 67

    assign_stmt  ->  IDENT ASSIGN expr SEMI .   (rule 31)

    $default	reduce using rule 31 (assign_stmt)



state 68

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI . RCURLY   (rule 14)

    RCURLY	shift, and go to state 79



state 69

    condition  ->  LPAREN bool_expr RPAREN .   (rule 32)

    $default	reduce using rule 32 (condition)



state 70

    bool_op  ->  EQ .   (rule 34)

    $default	reduce using rule 34 (bool_op)



state 71

    bool_op  ->  LT .   (rule 36)

    $default	reduce using rule 36 (bool_op)



state 72

    bool_op  ->  LE .   (rule 35)

    $default	reduce using rule 35 (bool_op)



state 73

    bool_op  ->  GE .   (rule 38)

    $default	reduce using rule 38 (bool_op)



state 74

    bool_op  ->  GT .   (rule 37)

    $default	reduce using rule 37 (bool_op)



state 75

    bool_op  ->  NE .   (rule 39)

    $default	reduce using rule 39 (bool_op)



state 76

    bool_expr  ->  term bool_op . term   (rule 33)

    error	shift, and go to state 1
    IDENT	shift, and go to state 18
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19

    term	go to state 80
    number	go to state 22



state 77

    block  ->  LCURLY stmt_seq . RCURLY   (rule 20)
    stmt_seq  ->  stmt_seq . stmt   (rule 23)

    error	shift, and go to state 44
    IDENT	shift, and go to state 45
    ICONST	shift, and go to state 2
    FCONST	shift, and go to state 3
    CCONST	shift, and go to state 19
    WHILE	shift, and go to state 47
    IF  	shift, and go to state 48
    SEMI	shift, and go to state 49
    RCURLY	shift, and go to state 81

    stmt	go to state 50
    assign_stmt	go to state 51
    expr	go to state 52
    term	go to state 21
    number	go to state 22



state 78

    stmt  ->  IF condition block ELSE . block   (rule 29)

    error	shift, and go to state 63
    LCURLY	shift, and go to state 64

    block	go to state 82



state 79

    func  ->  type_spec IDENT @2 LPAREN @3 param_list RPAREN @4 LCURLY stmt_seq RET expr @5 SEMI RCURLY .   (rule 14)

    $default	reduce using rule 14 (func)



state 80

    bool_expr  ->  term bool_op term .   (rule 33)

    $default	reduce using rule 33 (bool_expr)



state 81

    block  ->  LCURLY stmt_seq RCURLY .   (rule 20)

    $default	reduce using rule 20 (block)



state 82

    stmt  ->  IF condition block ELSE block .   (rule 29)

    $default	reduce using rule 29 (stmt)



state 83

    $   	go to state 84



state 84

    $   	go to state 85



state 85

    $default	accept
