

Terminals which are not used:

   SCONST
   LBRACK
   RBRACK
   PLUSEQ
   MINUSEQ
   ERROR


State 12 contains 6 reduce/reduce conflicts.
State 42 contains 1 shift/reduce conflict.
State 45 contains 5 reduce/reduce conflicts.
State 65 contains 1 shift/reduce conflict.

Grammar
rule 1    program -> decl_seq func
rule 2    decl_seq ->		/* empty */
rule 3    decl_seq -> decl_seq decl
rule 4    decl -> type_spec IDENT SEMI
rule 5    decl -> type_spec IDENT ASSIGN expr SEMI
rule 6    type_spec -> INT
rule 7    type_spec -> FLOAT
rule 8    type_spec -> CHAR
rule 9    @1 ->		/* empty */
rule 10   @2 ->		/* empty */
rule 11   @3 ->		/* empty */
rule 12   @4 ->		/* empty */
rule 13   func -> type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY
rule 14   param_list ->		/* empty */
rule 15   param_list -> param_seq
rule 16   param_seq -> param
rule 17   param_seq -> param COMMA param_seq
rule 18   param -> type_spec IDENT
rule 19   block -> LCURLY stmt_seq RCURLY
rule 20   block -> error
rule 21   stmt_seq ->		/* empty */
rule 22   stmt_seq -> stmt_seq stmt
rule 23   stmt_seq -> error
rule 24   stmt -> SEMI
rule 25   stmt -> expr SEMI
rule 26   stmt -> assign_stmt
rule 27   stmt -> WHILE condition block
rule 28   stmt -> IF condition block ELSE block
rule 29   stmt -> error
rule 30   assign_stmt -> IDENT ASSIGN expr SEMI
rule 31   condition -> LPAREN bool_expr RPAREN
rule 32   bool_expr -> term bool_op term
rule 33   bool_op -> EQ
rule 34   bool_op -> LE
rule 35   bool_op -> LT
rule 36   bool_op -> GT
rule 37   bool_op -> GE
rule 38   bool_op -> NE
rule 39   expr -> expr op term
rule 40   expr -> term
rule 41   expr -> error
rule 42   op -> TIMES
rule 43   op -> PLUS
rule 44   op -> MINUS
rule 45   op -> OVER
rule 46   term -> number
rule 47   term -> IDENT
rule 48   term -> CCONST
rule 49   term -> LPAREN expr RPAREN
rule 50   number -> ICONST
rule 51   number -> FCONST
rule 52   number -> error

Terminals, with rules where they appear

$ (-1)
error (256) 20 23 29 41 52
IDENT (258) 4 5 13 18 30 47
ICONST (259) 50
FCONST (260) 51
CCONST (261) 48
SCONST (262)
INT (263) 6
FLOAT (264) 7
CHAR (265) 8
RET (266) 13
WHILE (267) 27
IF (268) 28
ELSE (269) 28
LPAREN (270) 13 31 49
RPAREN (271) 13 31 49
SEMI (272) 4 5 13 24 25 30
COMMA (273) 17
LBRACK (274)
RBRACK (275)
LCURLY (276) 13 19
RCURLY (277) 13 19
ASSIGN (278) 5 30
EQ (279) 33
LT (280) 35
LE (281) 34
GE (282) 37
GT (283) 36
NE (284) 38
PLUS (285) 43
MINUS (286) 44
TIMES (287) 42
OVER (288) 45
PLUSEQ (289)
MINUSEQ (290)
ERROR (291)

Nonterminals, with rules where they appear

program (37)
    on left: 1
decl_seq (38)
    on left: 2 3, on right: 1 3
decl (39)
    on left: 4 5, on right: 3
type_spec (40)
    on left: 6 7 8, on right: 4 5 13 18
func (41)
    on left: 13, on right: 1
@1 (42)
    on left: 9, on right: 13
@2 (43)
    on left: 10, on right: 13
@3 (44)
    on left: 11, on right: 13
@4 (45)
    on left: 12, on right: 13
param_list (46)
    on left: 14 15, on right: 13
param_seq (47)
    on left: 16 17, on right: 15 17
param (48)
    on left: 18, on right: 16 17
block (49)
    on left: 19 20, on right: 27 28
stmt_seq (50)
    on left: 21 22 23, on right: 13 19 22
stmt (51)
    on left: 24 25 26 27 28 29, on right: 22
assign_stmt (52)
    on left: 30, on right: 26
condition (53)
    on left: 31, on right: 27 28
bool_expr (54)
    on left: 32, on right: 31
bool_op (55)
    on left: 33 34 35 36 37 38, on right: 32
expr (56)
    on left: 39 40 41, on right: 5 13 25 30 39 49
op (57)
    on left: 42 43 44 45, on right: 39
term (58)
    on left: 46 47 48 49, on right: 32 39 40
number (59)
    on left: 50 51 52, on right: 46


state 0

    $default	reduce using rule 2 (decl_seq)

    program	go to state 84
    decl_seq	go to state 1



state 1

    program  ->  decl_seq . func   (rule 1)
    decl_seq  ->  decl_seq . decl   (rule 3)

    INT 	shift, and go to state 2
    FLOAT	shift, and go to state 3
    CHAR	shift, and go to state 4

    decl	go to state 5
    type_spec	go to state 6
    func	go to state 7



state 2

    type_spec  ->  INT .   (rule 6)

    $default	reduce using rule 6 (type_spec)



state 3

    type_spec  ->  FLOAT .   (rule 7)

    $default	reduce using rule 7 (type_spec)



state 4

    type_spec  ->  CHAR .   (rule 8)

    $default	reduce using rule 8 (type_spec)



state 5

    decl_seq  ->  decl_seq decl .   (rule 3)

    $default	reduce using rule 3 (decl_seq)



state 6

    decl  ->  type_spec . IDENT SEMI   (rule 4)
    decl  ->  type_spec . IDENT ASSIGN expr SEMI   (rule 5)
    func  ->  type_spec . IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    IDENT	shift, and go to state 8



state 7

    program  ->  decl_seq func .   (rule 1)

    $default	reduce using rule 1 (program)



state 8

    decl  ->  type_spec IDENT . SEMI   (rule 4)
    decl  ->  type_spec IDENT . ASSIGN expr SEMI   (rule 5)
    func  ->  type_spec IDENT . @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    SEMI	shift, and go to state 9
    ASSIGN	shift, and go to state 10

    $default	reduce using rule 9 (@1)

    @1  	go to state 11



state 9

    decl  ->  type_spec IDENT SEMI .   (rule 4)

    $default	reduce using rule 4 (decl)



state 10

    decl  ->  type_spec IDENT ASSIGN . expr SEMI   (rule 5)

    error	shift, and go to state 12
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    expr	go to state 18
    term	go to state 19
    number	go to state 20



state 11

    func  ->  type_spec IDENT @1 . LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    LPAREN	shift, and go to state 21



state 12

    expr  ->  error .   (rule 41)
    number  ->  error .   (rule 52)

    RPAREN	reduce using rule 41 (expr)
    RPAREN	[reduce using rule 52 (number)]
    SEMI	reduce using rule 41 (expr)
    SEMI	[reduce using rule 52 (number)]
    PLUS	reduce using rule 41 (expr)
    PLUS	[reduce using rule 52 (number)]
    MINUS	reduce using rule 41 (expr)
    MINUS	[reduce using rule 52 (number)]
    $default	reduce using rule 41 (expr)



state 13

    term  ->  IDENT .   (rule 47)

    $default	reduce using rule 47 (term)



state 14

    number  ->  ICONST .   (rule 50)

    $default	reduce using rule 50 (number)



state 15

    number  ->  FCONST .   (rule 51)

    $default	reduce using rule 51 (number)



state 16

    term  ->  CCONST .   (rule 48)

    $default	reduce using rule 48 (term)



state 17

    term  ->  LPAREN . expr RPAREN   (rule 49)

    error	shift, and go to state 12
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    expr	go to state 22
    term	go to state 19
    number	go to state 20



state 18

    decl  ->  type_spec IDENT ASSIGN expr . SEMI   (rule 5)
    expr  ->  expr . op term   (rule 39)

    SEMI	shift, and go to state 23
    PLUS	shift, and go to state 24
    MINUS	shift, and go to state 25
    TIMES	shift, and go to state 26
    OVER	shift, and go to state 27

    op  	go to state 28



state 19

    expr  ->  term .   (rule 40)

    $default	reduce using rule 40 (expr)



state 20

    term  ->  number .   (rule 46)

    $default	reduce using rule 46 (term)



state 21

    func  ->  type_spec IDENT @1 LPAREN . @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    $default	reduce using rule 10 (@2)

    @2  	go to state 29



state 22

    expr  ->  expr . op term   (rule 39)
    term  ->  LPAREN expr . RPAREN   (rule 49)

    RPAREN	shift, and go to state 30
    PLUS	shift, and go to state 24
    MINUS	shift, and go to state 25
    TIMES	shift, and go to state 26
    OVER	shift, and go to state 27

    op  	go to state 28



state 23

    decl  ->  type_spec IDENT ASSIGN expr SEMI .   (rule 5)

    $default	reduce using rule 5 (decl)



state 24

    op  ->  PLUS .   (rule 43)

    $default	reduce using rule 43 (op)



state 25

    op  ->  MINUS .   (rule 44)

    $default	reduce using rule 44 (op)



state 26

    op  ->  TIMES .   (rule 42)

    $default	reduce using rule 42 (op)



state 27

    op  ->  OVER .   (rule 45)

    $default	reduce using rule 45 (op)



state 28

    expr  ->  expr op . term   (rule 39)

    error	shift, and go to state 31
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    term	go to state 32
    number	go to state 20



state 29

    func  ->  type_spec IDENT @1 LPAREN @2 . param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    INT 	shift, and go to state 2
    FLOAT	shift, and go to state 3
    CHAR	shift, and go to state 4

    $default	reduce using rule 14 (param_list)

    type_spec	go to state 33
    param_list	go to state 34
    param_seq	go to state 35
    param	go to state 36



state 30

    term  ->  LPAREN expr RPAREN .   (rule 49)

    $default	reduce using rule 49 (term)



state 31

    number  ->  error .   (rule 52)

    $default	reduce using rule 52 (number)



state 32

    expr  ->  expr op term .   (rule 39)

    $default	reduce using rule 39 (expr)



state 33

    param  ->  type_spec . IDENT   (rule 18)

    IDENT	shift, and go to state 37



state 34

    func  ->  type_spec IDENT @1 LPAREN @2 param_list . RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    RPAREN	shift, and go to state 38



state 35

    param_list  ->  param_seq .   (rule 15)

    $default	reduce using rule 15 (param_list)



state 36

    param_seq  ->  param .   (rule 16)
    param_seq  ->  param . COMMA param_seq   (rule 17)

    COMMA	shift, and go to state 39

    $default	reduce using rule 16 (param_seq)



state 37

    param  ->  type_spec IDENT .   (rule 18)

    $default	reduce using rule 18 (param)



state 38

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN . @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    $default	reduce using rule 11 (@3)

    @3  	go to state 40



state 39

    param_seq  ->  param COMMA . param_seq   (rule 17)

    INT 	shift, and go to state 2
    FLOAT	shift, and go to state 3
    CHAR	shift, and go to state 4

    type_spec	go to state 33
    param_seq	go to state 41
    param	go to state 36



state 40

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 . LCURLY stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    LCURLY	shift, and go to state 42



state 41

    param_seq  ->  param COMMA param_seq .   (rule 17)

    $default	reduce using rule 17 (param_seq)



state 42

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY . stmt_seq RET expr @4 SEMI RCURLY   (rule 13)

    error	shift, and go to state 43

    error	[reduce using rule 21 (stmt_seq)]
    IDENT	reduce using rule 21 (stmt_seq)
    ICONST	reduce using rule 21 (stmt_seq)
    FCONST	reduce using rule 21 (stmt_seq)
    CCONST	reduce using rule 21 (stmt_seq)
    RET 	reduce using rule 21 (stmt_seq)
    WHILE	reduce using rule 21 (stmt_seq)
    IF  	reduce using rule 21 (stmt_seq)
    LPAREN	reduce using rule 21 (stmt_seq)
    SEMI	reduce using rule 21 (stmt_seq)
    OVER	reduce using rule 21 (stmt_seq)
    MINUSEQ	reduce using rule 21 (stmt_seq)
    ERROR	reduce using rule 21 (stmt_seq)

    stmt_seq	go to state 44



state 43

    stmt_seq  ->  error .   (rule 23)

    $default	reduce using rule 23 (stmt_seq)



state 44

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq . RET expr @4 SEMI RCURLY   (rule 13)
    stmt_seq  ->  stmt_seq . stmt   (rule 22)

    error	shift, and go to state 45
    IDENT	shift, and go to state 46
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    RET 	shift, and go to state 47
    WHILE	shift, and go to state 48
    IF  	shift, and go to state 49
    LPAREN	shift, and go to state 17
    SEMI	shift, and go to state 50

    stmt	go to state 51
    assign_stmt	go to state 52
    expr	go to state 53
    term	go to state 19
    number	go to state 20



state 45

    stmt  ->  error .   (rule 29)
    expr  ->  error .   (rule 41)
    number  ->  error .   (rule 52)

    SEMI	reduce using rule 29 (stmt)
    SEMI	[reduce using rule 41 (expr)]
    SEMI	[reduce using rule 52 (number)]
    PLUS	reduce using rule 41 (expr)
    PLUS	[reduce using rule 52 (number)]
    MINUS	reduce using rule 41 (expr)
    MINUS	[reduce using rule 52 (number)]
    $default	reduce using rule 29 (stmt)



state 46

    assign_stmt  ->  IDENT . ASSIGN expr SEMI   (rule 30)
    term  ->  IDENT .   (rule 47)

    ASSIGN	shift, and go to state 54

    $default	reduce using rule 47 (term)



state 47

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET . expr @4 SEMI RCURLY   (rule 13)

    error	shift, and go to state 12
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    expr	go to state 55
    term	go to state 19
    number	go to state 20



state 48

    stmt  ->  WHILE . condition block   (rule 27)

    LPAREN	shift, and go to state 56

    condition	go to state 57



state 49

    stmt  ->  IF . condition block ELSE block   (rule 28)

    LPAREN	shift, and go to state 56

    condition	go to state 58



state 50

    stmt  ->  SEMI .   (rule 24)

    $default	reduce using rule 24 (stmt)



state 51

    stmt_seq  ->  stmt_seq stmt .   (rule 22)

    $default	reduce using rule 22 (stmt_seq)



state 52

    stmt  ->  assign_stmt .   (rule 26)

    $default	reduce using rule 26 (stmt)



state 53

    stmt  ->  expr . SEMI   (rule 25)
    expr  ->  expr . op term   (rule 39)

    SEMI	shift, and go to state 59
    PLUS	shift, and go to state 24
    MINUS	shift, and go to state 25
    TIMES	shift, and go to state 26
    OVER	shift, and go to state 27

    op  	go to state 28



state 54

    assign_stmt  ->  IDENT ASSIGN . expr SEMI   (rule 30)

    error	shift, and go to state 12
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    expr	go to state 60
    term	go to state 19
    number	go to state 20



state 55

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr . @4 SEMI RCURLY   (rule 13)
    expr  ->  expr . op term   (rule 39)

    PLUS	shift, and go to state 24
    MINUS	shift, and go to state 25
    TIMES	shift, and go to state 26
    OVER	shift, and go to state 27

    $default	reduce using rule 12 (@4)

    @4  	go to state 61
    op  	go to state 28



state 56

    condition  ->  LPAREN . bool_expr RPAREN   (rule 31)

    error	shift, and go to state 31
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    bool_expr	go to state 62
    term	go to state 63
    number	go to state 20



state 57

    stmt  ->  WHILE condition . block   (rule 27)

    error	shift, and go to state 64
    LCURLY	shift, and go to state 65

    block	go to state 66



state 58

    stmt  ->  IF condition . block ELSE block   (rule 28)

    error	shift, and go to state 64
    LCURLY	shift, and go to state 65

    block	go to state 67



state 59

    stmt  ->  expr SEMI .   (rule 25)

    $default	reduce using rule 25 (stmt)



state 60

    assign_stmt  ->  IDENT ASSIGN expr . SEMI   (rule 30)
    expr  ->  expr . op term   (rule 39)

    SEMI	shift, and go to state 68
    PLUS	shift, and go to state 24
    MINUS	shift, and go to state 25
    TIMES	shift, and go to state 26
    OVER	shift, and go to state 27

    op  	go to state 28



state 61

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 . SEMI RCURLY   (rule 13)

    SEMI	shift, and go to state 69



state 62

    condition  ->  LPAREN bool_expr . RPAREN   (rule 31)

    RPAREN	shift, and go to state 70



state 63

    bool_expr  ->  term . bool_op term   (rule 32)

    EQ  	shift, and go to state 71
    LT  	shift, and go to state 72
    LE  	shift, and go to state 73
    GE  	shift, and go to state 74
    GT  	shift, and go to state 75
    NE  	shift, and go to state 76

    bool_op	go to state 77



state 64

    block  ->  error .   (rule 20)

    $default	reduce using rule 20 (block)



state 65

    block  ->  LCURLY . stmt_seq RCURLY   (rule 19)

    error	shift, and go to state 43

    error	[reduce using rule 21 (stmt_seq)]
    IDENT	reduce using rule 21 (stmt_seq)
    ICONST	reduce using rule 21 (stmt_seq)
    FCONST	reduce using rule 21 (stmt_seq)
    CCONST	reduce using rule 21 (stmt_seq)
    WHILE	reduce using rule 21 (stmt_seq)
    IF  	reduce using rule 21 (stmt_seq)
    LPAREN	reduce using rule 21 (stmt_seq)
    SEMI	reduce using rule 21 (stmt_seq)
    RCURLY	reduce using rule 21 (stmt_seq)
    OVER	reduce using rule 21 (stmt_seq)
    MINUSEQ	reduce using rule 21 (stmt_seq)
    ERROR	reduce using rule 21 (stmt_seq)

    stmt_seq	go to state 78



state 66

    stmt  ->  WHILE condition block .   (rule 27)

    $default	reduce using rule 27 (stmt)



state 67

    stmt  ->  IF condition block . ELSE block   (rule 28)

    ELSE	shift, and go to state 79



state 68

    assign_stmt  ->  IDENT ASSIGN expr SEMI .   (rule 30)

    $default	reduce using rule 30 (assign_stmt)



state 69

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI . RCURLY   (rule 13)

    RCURLY	shift, and go to state 80



state 70

    condition  ->  LPAREN bool_expr RPAREN .   (rule 31)

    $default	reduce using rule 31 (condition)



state 71

    bool_op  ->  EQ .   (rule 33)

    $default	reduce using rule 33 (bool_op)



state 72

    bool_op  ->  LT .   (rule 35)

    $default	reduce using rule 35 (bool_op)



state 73

    bool_op  ->  LE .   (rule 34)

    $default	reduce using rule 34 (bool_op)



state 74

    bool_op  ->  GE .   (rule 37)

    $default	reduce using rule 37 (bool_op)



state 75

    bool_op  ->  GT .   (rule 36)

    $default	reduce using rule 36 (bool_op)



state 76

    bool_op  ->  NE .   (rule 38)

    $default	reduce using rule 38 (bool_op)



state 77

    bool_expr  ->  term bool_op . term   (rule 32)

    error	shift, and go to state 31
    IDENT	shift, and go to state 13
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    LPAREN	shift, and go to state 17

    term	go to state 81
    number	go to state 20



state 78

    block  ->  LCURLY stmt_seq . RCURLY   (rule 19)
    stmt_seq  ->  stmt_seq . stmt   (rule 22)

    error	shift, and go to state 45
    IDENT	shift, and go to state 46
    ICONST	shift, and go to state 14
    FCONST	shift, and go to state 15
    CCONST	shift, and go to state 16
    WHILE	shift, and go to state 48
    IF  	shift, and go to state 49
    LPAREN	shift, and go to state 17
    SEMI	shift, and go to state 50
    RCURLY	shift, and go to state 82

    stmt	go to state 51
    assign_stmt	go to state 52
    expr	go to state 53
    term	go to state 19
    number	go to state 20



state 79

    stmt  ->  IF condition block ELSE . block   (rule 28)

    error	shift, and go to state 64
    LCURLY	shift, and go to state 65

    block	go to state 83



state 80

    func  ->  type_spec IDENT @1 LPAREN @2 param_list RPAREN @3 LCURLY stmt_seq RET expr @4 SEMI RCURLY .   (rule 13)

    $default	reduce using rule 13 (func)



state 81

    bool_expr  ->  term bool_op term .   (rule 32)

    $default	reduce using rule 32 (bool_expr)



state 82

    block  ->  LCURLY stmt_seq RCURLY .   (rule 19)

    $default	reduce using rule 19 (block)



state 83

    stmt  ->  IF condition block ELSE block .   (rule 28)

    $default	reduce using rule 28 (stmt)



state 84

    $   	go to state 85



state 85

    $   	go to state 86



state 86

    $default	accept
