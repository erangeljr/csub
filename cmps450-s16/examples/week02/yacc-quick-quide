FLEX BARE ESSENTIALS 

************
* OVERVIEW *
************

Step 1. Create a flex program with extension .l (el)      $ vi sample.l
Step 2. Use flex to translate the program into lex.yy.c   $ flex sample.l
Step 3. Compile with gcc and link in flex library         $ gcc lex.yy.c -lfl
Step 4. Run the scanner (a.out) against a file            $ cat test | ./a.out

********************************
* INPUT FILE FORMAT AND SYNTAX *
********************************

A Lex input file is similar to awk (if that helps). The input file has three 
sections, separated by a line with %% in it:

         %{ C globals %}
         definitions
         %%
         rules
         %%
         user C code

The definitions section contains any C code that you want to have external 
linkage (lifetime of the executable and external linkage). The definitions 
section is delimited by %{ and %}. The definitions section also contains 
names for regular expressions. 

Each pattern in a rule has a corresponding action written as a line (or block)
of C code.

*******************
* THE BIG PICTURE *
*******************

From your source, Lex generates C code for a lexical analyzer that can either 
be inserted into a larger C program or executed as a standalone program. You 
automatically have access to the following defines/functions:

 yyin      # stdin by default 
 yyout     # stdout by default
 yytext    # pointer to the string matched to the regexp
 yyleng    # the length of the lexeme
 yylineno  # flex keeps track of lineno of current token - you must initialize 
 yylex     # the name of the scanner procedure constructed by Lex 
 yywrap    # this function is called at EOF of input file
 yylval    # holds value from yylex for current lexeme - type int by default 
 yy.lex.c  # the name of the C program constructed by Lex 
 input     # Lex buffered input routine - grabs one character at a time
 ECHO      # Lex default action -- display yytext to yyout 
 yyless(n) # spits back all but first n characters of curent token 
 yyclearin # clears the current token - useful for error recovery

Default behavior:
+ yylex returns a token number of type int (or 0 at EOF)
+ lex matches the longest possible substring even if the rule is not first
+ if a substring matches two+ rules, Lex picks the 1st rule in the order listed
+ if substring maches none of the regexps, Lex will echo the string to yyout
+ dot (.) matches any character except newline \n
+ [^a] matches anything but 'a' including newline


