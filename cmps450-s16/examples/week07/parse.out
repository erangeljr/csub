id * id + id

Starting parse
Entering state 0
Reading a token: Next token is (IDENT)
Shifting token (IDENT), Entering state 1
Reducing via rule 6, IDENT -> factor
state stack now 0
Entering state 5
Reducing via rule 4, factor -> term
state stack now 0
Entering state 4
Reading a token: Next token is (TIMES)
Shifting token (TIMES), Entering state 8
Reading a token: Next token is (IDENT)
Shifting token (IDENT), Entering state 1
Reducing via rule 6, IDENT -> factor
state stack now 0 4 8
Entering state 11
Reducing via rule 3, term TIMES factor -> term
state stack now 0
Entering state 4
Reading a token: Next token is (PLUS)
Reducing via rule 2, term -> expr
state stack now 0
Entering state 3
Next token is (PLUS)
Shifting token (PLUS), Entering state 7
Reading a token: Next token is (IDENT)
Shifting token (IDENT), Entering state 1
Reducing via rule 6, IDENT -> factor
state stack now 0 3 7
Entering state 5
Reducing via rule 4, factor -> term
state stack now 0 3 7
Entering state 10
Reading a token: Now at end of input.
Reducing via rule 1, expr PLUS term -> expr
state stack now 0
Entering state 3
Now at end of input.
Shifting token ($), Entering state 12
Now at end of input.
--------------------------------------------------
y.output

Grammar
rule 1  expr -> expr PLUS term
rule 2  expr -> term
rule 3  term -> term TIMES factor
rule 4  term -> factor
rule 5  factor -> LPAREN expr RPAREN
rule 6  factor -> IDENT

state 0
  IDENT	shift, and go to state 1
  LPAREN	shift, and go to state 2
  expr	go to state 3
  term	go to state 4
  factor	go to state 5
state 1
  factor -> IDENT .  (rule 6)
  $default	reduce using rule 6 (factor)
state 2
  factor -> LPAREN . expr RPAREN  (rule 5)
  IDENT	shift, and go to state 1
  LPAREN	shift, and go to state 2
  expr	go to state 6
  term	go to state 4
  factor	go to state 5
state 3
  expr -> expr . PLUS term  (rule 1)
  $  	go to state 12
  PLUS	shift, and go to state 7
state 4
  expr -> term .  (rule 2)
  term -> term . TIMES factor  (rule 3)
  TIMES	shift, and go to state 8
  $default	reduce using rule 2 (expr)
state 5
  term -> factor .  (rule 4)
  $default	reduce using rule 4 (term)
state 6
  expr -> expr . PLUS term  (rule 1)
  factor -> LPAREN expr . RPAREN  (rule 5)
  PLUS	shift, and go to state 7
  RPAREN	shift, and go to state 9
state 7
  expr -> expr PLUS . term  (rule 1)
  IDENT	shift, and go to state 1
  LPAREN	shift, and go to state 2
  term	go to state 10
  factor	go to state 5
state 8
  term -> term TIMES . factor  (rule 3)
  IDENT	shift, and go to state 1
  LPAREN	shift, and go to state 2
  factor	go to state 11
state 9
  factor -> LPAREN expr RPAREN .  (rule 5)
  $default	reduce using rule 5 (factor)
state 10
  expr -> expr PLUS term .  (rule 1)
  term -> term . TIMES factor  (rule 3)
  TIMES	shift, and go to state 8
  $default	reduce using rule 1 (expr)
state 11
  term -> term TIMES factor .  (rule 3)
  $default	reduce using rule 3 (term)
state 12
  $  	go to state 13
state 13
  $default	accept

------------------------------------------------------------
NOTES.
$default matches whatever the lookahead might be. 
Only kernel items are listed in states
