

Terminals which are not used:

   LPAREN
   RPAREN
   ERROR


State 3 contains 1 reduce/reduce conflict.
State 18 contains 1 reduce/reduce conflict.

Grammar
rule 1    block -> LCURLY stmt_seq RCURLY
rule 2    block -> error
rule 3    stmt_seq -> stmt_seq stmt SEMI
rule 4    stmt_seq -> stmt SEMI
rule 5    stmt_seq -> error
rule 6    stmt -> expr
rule 7    stmt -> decl
rule 8    stmt -> assignmnt
rule 9    stmt -> error
rule 10   decl -> decltype IDENT
rule 11   expr -> expr PLUS term
rule 12   expr -> term
rule 13   expr -> error
rule 14   assignmnt -> IDENT ASSIGN expr
rule 15   term -> number
rule 16   term -> IDENT
rule 17   decltype -> INT
rule 18   decltype -> FLOAT
rule 19   number -> INTEGER
rule 20   number -> REALNUM

Terminals, with rules where they appear

$ (-1)
error (256) 2 5 9 13
IDENT (258) 10 14 16
INTEGER (259) 19
REALNUM (260) 20
FLOAT (261) 18
INT (262) 17
LCURLY (263) 1
RCURLY (264) 1
SEMI (265) 3 4
PLUS (266) 11
ASSIGN (267) 14
LPAREN (268)
RPAREN (269)
ERROR (270)

Nonterminals, with rules where they appear

block (16)
    on left: 1 2
stmt_seq (17)
    on left: 3 4 5, on right: 1 3
stmt (18)
    on left: 6 7 8 9, on right: 3 4
decl (19)
    on left: 10, on right: 7
expr (20)
    on left: 11 12 13, on right: 6 11 14
assignmnt (21)
    on left: 14, on right: 8
term (22)
    on left: 15 16, on right: 11 12
decltype (23)
    on left: 17 18, on right: 10
number (24)
    on left: 19 20, on right: 15


state 0

    error	shift, and go to state 1
    LCURLY	shift, and go to state 2

    block	go to state 29



state 1

    block  ->  error .   (rule 2)

    $default	reduce using rule 2 (block)



state 2

    block  ->  LCURLY . stmt_seq RCURLY   (rule 1)

    error	shift, and go to state 3
    IDENT	shift, and go to state 4
    INTEGER	shift, and go to state 5
    REALNUM	shift, and go to state 6
    FLOAT	shift, and go to state 7
    INT 	shift, and go to state 8

    stmt_seq	go to state 9
    stmt	go to state 10
    decl	go to state 11
    expr	go to state 12
    assignmnt	go to state 13
    term	go to state 14
    decltype	go to state 15
    number	go to state 16



state 3

    stmt_seq  ->  error .   (rule 5)
    stmt  ->  error .   (rule 9)
    expr  ->  error .   (rule 13)

    SEMI	reduce using rule 9 (stmt)
    SEMI	[reduce using rule 13 (expr)]
    PLUS	reduce using rule 13 (expr)
    $default	reduce using rule 5 (stmt_seq)



state 4

    assignmnt  ->  IDENT . ASSIGN expr   (rule 14)
    term  ->  IDENT .   (rule 16)

    ASSIGN	shift, and go to state 17

    $default	reduce using rule 16 (term)



state 5

    number  ->  INTEGER .   (rule 19)

    $default	reduce using rule 19 (number)



state 6

    number  ->  REALNUM .   (rule 20)

    $default	reduce using rule 20 (number)



state 7

    decltype  ->  FLOAT .   (rule 18)

    $default	reduce using rule 18 (decltype)



state 8

    decltype  ->  INT .   (rule 17)

    $default	reduce using rule 17 (decltype)



state 9

    block  ->  LCURLY stmt_seq . RCURLY   (rule 1)
    stmt_seq  ->  stmt_seq . stmt SEMI   (rule 3)

    error	shift, and go to state 18
    IDENT	shift, and go to state 4
    INTEGER	shift, and go to state 5
    REALNUM	shift, and go to state 6
    FLOAT	shift, and go to state 7
    INT 	shift, and go to state 8
    RCURLY	shift, and go to state 19

    stmt	go to state 20
    decl	go to state 11
    expr	go to state 12
    assignmnt	go to state 13
    term	go to state 14
    decltype	go to state 15
    number	go to state 16



state 10

    stmt_seq  ->  stmt . SEMI   (rule 4)

    SEMI	shift, and go to state 21



state 11

    stmt  ->  decl .   (rule 7)

    $default	reduce using rule 7 (stmt)



state 12

    stmt  ->  expr .   (rule 6)
    expr  ->  expr . PLUS term   (rule 11)

    PLUS	shift, and go to state 22

    $default	reduce using rule 6 (stmt)



state 13

    stmt  ->  assignmnt .   (rule 8)

    $default	reduce using rule 8 (stmt)



state 14

    expr  ->  term .   (rule 12)

    $default	reduce using rule 12 (expr)



state 15

    decl  ->  decltype . IDENT   (rule 10)

    IDENT	shift, and go to state 23



state 16

    term  ->  number .   (rule 15)

    $default	reduce using rule 15 (term)



state 17

    assignmnt  ->  IDENT ASSIGN . expr   (rule 14)

    error	shift, and go to state 24
    IDENT	shift, and go to state 25
    INTEGER	shift, and go to state 5
    REALNUM	shift, and go to state 6

    expr	go to state 26
    term	go to state 14
    number	go to state 16



state 18

    stmt  ->  error .   (rule 9)
    expr  ->  error .   (rule 13)

    SEMI	reduce using rule 9 (stmt)
    SEMI	[reduce using rule 13 (expr)]
    PLUS	reduce using rule 13 (expr)
    $default	reduce using rule 9 (stmt)



state 19

    block  ->  LCURLY stmt_seq RCURLY .   (rule 1)

    $default	reduce using rule 1 (block)



state 20

    stmt_seq  ->  stmt_seq stmt . SEMI   (rule 3)

    SEMI	shift, and go to state 27



state 21

    stmt_seq  ->  stmt SEMI .   (rule 4)

    $default	reduce using rule 4 (stmt_seq)



state 22

    expr  ->  expr PLUS . term   (rule 11)

    IDENT	shift, and go to state 25
    INTEGER	shift, and go to state 5
    REALNUM	shift, and go to state 6

    term	go to state 28
    number	go to state 16



state 23

    decl  ->  decltype IDENT .   (rule 10)

    $default	reduce using rule 10 (decl)



state 24

    expr  ->  error .   (rule 13)

    $default	reduce using rule 13 (expr)



state 25

    term  ->  IDENT .   (rule 16)

    $default	reduce using rule 16 (term)



state 26

    expr  ->  expr . PLUS term   (rule 11)
    assignmnt  ->  IDENT ASSIGN expr .   (rule 14)

    PLUS	shift, and go to state 22

    $default	reduce using rule 14 (assignmnt)



state 27

    stmt_seq  ->  stmt_seq stmt SEMI .   (rule 3)

    $default	reduce using rule 3 (stmt_seq)



state 28

    expr  ->  expr PLUS term .   (rule 11)

    $default	reduce using rule 11 (expr)



state 29

    $   	go to state 30



state 30

    $   	go to state 31



state 31

    $default	accept
