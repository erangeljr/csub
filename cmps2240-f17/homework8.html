<!DOCTYPE html>
<html>
<body>
<link rel="stylesheet" href="./cssReset.css">
<style>
	a:link    {color:#751;} /* unvisited link */
	a:visited {color:#e74;} /* visited link */
	a:hover   {color:#000;background:#ec9;} /* mouse over link */
	a:active  {color:#0b0;} /* selected link */
	body {
		margin: 2% 5% 5% 5%;
		font-family: serif;
		background-color: #ffd;
		color: #19193A;
		font-weight: normal;
		font-size: 11pt;
		line-height:normal;
	}
	div {
		margin: 3px;
		padding: 4px;
		border: 1px dashed black;
		font-family: serif;
		font-size: 11pt;
		font-weight: 500;
		color: #000;
		background: #bdf;
		padding-right: 20px;
		height: auto;
		height: 60px;
	}
	.notes {
		background-color:papayawhip;
		width:250px;
		height:110px;
	}
	ul.a {
		list-style-type:circle;
		margin-left:26px;
		line-height:150%;
		/*color:#000000;*/
	}
	ul.b {
		list-style-type:disc;
		margin-left:26px;
		line-height:100%;
		/*color:#000000;*/
		color:#664422;
	}
	b { font-weight: 900; }
	code { font-family: monospace; }
	pre { font-family: monospace; font-size: 10pt; }
	input { background:#ed8; }
	h3 {
		font-size: 12pt;
		font-weight: 600;
		font-family: serif;
		padding-top: 4px;
		padding-bottom: 6px;
	}
	sup {
	    vertical-align: super;
	    font-size: smaller;
	}
</style>
<script type="text/javascript">
	//used to toggle hints on/off
	var xb = [0];
	for (var i=0; i<200; i++) xb[i] = 1;
	function zzz(doc, text) {
		document.getElementById(doc).innerHTML=text; 
	}
</script>
<body>

<h3>CMPS-224 Homework 8 - Intro to x86 Assembly</h3>
<br>
<p>
<div class="notes" style="width:600px;">
The answers to the questions below are found in this 
<a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">x86 assembly guide</a> by David Evans at the University of Virginia. Note that 
 this homework covers x86. You will be
 coding in x86-64 assembler. There are important extensions
 to x86-64 but you should understand a little about the x86 ISA
 before jumping in to x86-64.
 This <a href="http://www.cs.dartmouth.edu/~sergey/cs108/2009/x86_newnew.pdf">Tiny Guide</a> is enough for this homework.
</div>
</p>
<br>



1. What are the ESP and the EBP registers in x86 assembly used for?
<input type="button"value="hint"onClick="xb[ 1]^=1; zzz('x1', (xb[ 1])?'':
'ESP is the stack pointer EBP is the base pointer.'
);"><div id="x1"></div><br>


2. The 6 general purpose registers (GPRs) in x86 are EAX, EBX, ECX, EDX, 
 ESI, & EDI. There are
 also sub-registers. For example, explain
 the difference between the EAX, AX, AH and AL registers.
 Give the size of each.
<input type="button"value="hint"onClick="xb[ 2]^=1; zzz('x2', (xb[ 2])?'':
'EAX is a 32-bit register; AX is 2 least significant bytes (16-bits) \
of the EAX register. The least significant byte of AX is AL (low); \
The most significant byte of AX  is AH (high).'
);"><div id="x2"></div><br>


3. Describe what these declarations in the static data segment accomplish.
   Note that in x86 a  word is 2 bytes and a double word is 4 bytes.
<pre>
   .DATA
   var DB 64 
   var2  DB ? 
   DB 10     
   X  DW ?  
   Y  DD 3000
</pre> 
<input type="button"value="hint"onClick="xb[ 3]^=1; zzz('x3', (xb[ 3])?'':
'<pre> .DATA  \
var DB 64  ; Declare 1 byte, labeled var, containing the value 64.<br>\
var2  DB ? ; Declare 1 uninitialized byte, labeled var2. <br>\
DB 10      ; Declare 1 byte, no label, value = 10. location is var2 + 1.<br>\
X  DW ?    ; Declare 2-byte uninitialized value, labeled X. <br>\
Y  DD 3000 ; Declare 4-byte (double) value labeled Y, initialized to 3000.\
</pre>'
);"><div id="x3"style="height:90px"></div><br>


4. The DUP assembler directive duplicates an initialization. Explain these:
<pre>
    Z  DD 1, 2, 3
    bytes DB 10 DUP(?)
    arr  DD 100 DUP(0) 
    str  DB 'hello',0
</pre> 
<input type="button"value="hint"onClick="xb[ 4]^=1; zzz('x4', (xb[ 4])?'':
'<pre>  Z   DD 1, 2, 3   ; init 3 4-byte values to 1,2,3 (location Z+8=3)<br>\
bytes DB 10 DUP(?) ; Declare 10 uninitialized bytes starting at location \
bytes. <br>\
arr  DD 100 DUP(0) ; Initialize 100 4-byte words starting at arr with 0\
<br>\
str  DB hello,0    ; Declare 6 bytes starting at the address str, initialized\
<br>\
				   ; to the ASCII values for hello followed by the \
null (0) byte.</pre>'
);"><div id="x4"style="height:90px"></div><br>


5. Unlike MIPS, x86 supports direct accesses to memory. Note that
   a WORD is
   2 bytes and a DWORD is 4 bytes. The x86 registers EAX, EBX, ECX, EDX,
   ESI, EDI, ESP, and EBP  are 32-bit. Also note that with x86, data movement
   is always from right to left (there is no operation
   equivalent to the store operation in x86). With these facts in mind,
   explain the instructions below.
<pre>
    mov eax, [ebx]   
    mov [edx], eax   
    mov eax, [esi-4] 
    mov [esi+eax], cl 
    mov BYTE PTR [ebx], 12 
    mov WORD PTR [ebx], 5 
    mov DWORD PTR [ebx], 9
</pre>
<input type="button"value="hint"onClick="xb[ 5]^=1; zzz('x5', (xb[ 5])?'':
'<pre>\
mov eax, [ebx]         ; Move 4 bytes at address contained in EBX into EAX<br>\
mov [var], ebx         ; Move contents of EBX into 4 bytes at memory address var.<br>\
mov eax, [esi-4]       ; Move 4 bytes at memory address ESI + (-4) into EAX<br>\
mov [esi+eax], cl      ; Move contents of CL into the byte at address ESI+EAX<br>\
mov BYTE PTR [ebx], 12 ; move 12 into 1 byte at the address stored in EBX.<br>\
mov WORD PTR [ebx], 5  ; move 5 into 2 bytes starting at address in EBX.<br>\
mov DWORD PTR [ebx], 9 ; move 9 into 4 bytes starting at address in EBX.\
</pre>'
);"><div id="x5"style="height:130px"></div><br>


6. The MOV instruction supports register to memory, register to register or
   memory to register. Explain these:
<pre>
    mov eax, ebx 
    mov byte ptr [var], 5
</pre> 
<input type="button"value="hint"onClick="xb[ 6]^=1; zzz('x6', (xb[ 6])?'':
'<pre>\
  mov eax, ebx           ; copy the value in ebx into eax<br>\
  mov byte ptr [var], 5  ; store the value 5 into the byte at location var\
</pre>'
);"><div id="x6"></div><br>


7. The push instruction places its operand onto the top of the hardware 
   supported stack in memory. Push first decrements ESP by 4 (bytes), 
   then places 
   its operand into the contents of the 32-bit location at address [ESP]. 
   ESP (the stack pointer) is decremented by push first since the x86 stack 
   grows from high to low addresses. Explain these instructions:
<pre>
  push eax  
  push [var]
</pre>
<input type="button"value="hint"onClick="xb[ 7]^=1; zzz('x7', (xb[ 7])?'':
'<pre>\
  push eax   ; push contents of eax on the stack <br>\
  push [var] ; push the contents of 4 bytes at address var onto the stack\
</pre>'
);"><div id="x7"></div><br>


8. The pop instruction copies 4 bytes from the top of the 
   hardware stack at address SP to register or memory.  SP is
   then incremented by 4.  Explain these instructions:
<pre>
    pop edi
    pop [ebx]
</pre> 
<input type="button"value="hint"onClick="xb[ 8]^=1; zzz('x8', (xb[ 8])?'':
'<pre>\
    pop edi   ; pop top of the stack; move to register EDI<br>\
    pop [ebx] ; pop top of the stack; store to memory location in EBX.\
</pre>'
);"><div id="x8"></div><br>


9. The Load Effective Address instruction (lea)
   grabs the address of a label/symbol or computes an 
   address by adding an offset. The effective address is then loaded into the 
   target register. Explain these:
<pre>
    lea eax, [var] 
    lea edi, [ebx+4*esi]
</pre> 
<input type="button"value="hint"onClick="xb[ 9]^=1; zzz('x9', (xb[ 9])?'':
'<pre>\
 lea eax, [var]       ; address  of symbol var is loaded into register eax<br>\
 lea edi, [ebx+4*esi] ; address in ebx + offset is loaded into register edi\
</pre>'
);"><div id="x9"></div><br>


10. Unlike MIPS, arithmetic operations in x86
    can be performed register to register or register to
	memory. The second operand may be a constant. Explain these:
<pre>
    add eax, 10 
    add BYTE PTR [var], 10 
    sub al, ah 
    imul eax, [var]
    imul esi, edi, 25
</pre>
<input type="button"value="hint"onClick="xb[10]^=1; zzz('x10',(xb[10])?'':
'<pre>\
add eax, 10            ; increment value in eax by 10<br>\
add BYTE PTR [var], 10 ; increment byte pointed to by address in var by 10<br>\
sub al, ah             ; subtract value in AH from value in AL and stuff it in AL<br>\
imul eax, [var]        ; eax = eax * value at address var <br>\
imul esi, edi, 25      ; esi = edi * 25 ;\
</pre>'
);"><div id="x10"style="height:110px"></div><br>


11. Explain these inc, dec instructions
<pre>
    dec eax 
    inc DWORD PTR [var]
</pre>
<input type="button"value="hint"onClick="xb[11]^=1; zzz('x11',(xb[11])?'':
'<pre>\
 dec eax             ; subtract one from the contents of EAX.<br>\
 inc DWORD PTR [var] ; add one to the 32-bit integer stored at location var\
</pre>'
);"><div id="x11"></div><br>


12. Integer division utilizes a 64-bit register EDX:EAX (where EDX is the 
    most significant 32 bits). The idiv instruction divides the contents of 
    EDX:EAX by the operand. The quotient is stored into EAX and the 
	remainder in EDX.  Explain these operations:
<pre>
    idiv ebx
    idiv DWORD PTR [var]
</pre> 
<input type="button"value="hint"onClick="xb[12]^=1; zzz('x12',(xb[12])?'':
'<pre>\
idiv ebx             ; divide contents of EDX:EAX by the contents of EBX. Place <br>\
                     ; the quotient in EAX and the remainder in EDX. <br>\
idiv DWORD PTR [var] ; divide contents of EDX:EAX by 32-bit value stored <br>\
                     ; at memory location var, put quotient in EAX and \
remainder in EDX.</pre>'
);"><div id="x12"style="height:90px"></div><br>


13. The bitwise logical AND, OR and EXCLUSIVE OR instructions perform the 
    operation on the first register place the result in the first register.
    Explain these operations:
<pre>
    and eax, 0fH   # 0fH  is 15 in decimal - the H denotes hex 
    xor edx, edx
    neg edx
    not edx
</pre>
<input type="button"value="hint"onClick="xb[13]^=1; zzz('x13',(xb[13])?'':
'<pre>\
and eax, 0fH  ; clear all but the last 4 bits of EAX. <br>\
xor edx, edx  ; set the contents of EDX to zero. <br>\
neg edx       ; perform twos-complement negation of value in edx;e.g.5=-5.<br>\
not edx       ; flip all bits in edx\
</pre>'
);"><div id="x13"style="height:90px"></div><br>


14. The Shift Left and Shift Right instructions perform shifts on the first
    operand, padding empty bit positions with zeros. The second operand is
	either an 8-bit constant or the register CL. Explain these shift operations:
<pre>
    shl eax,1 
    shr ebx,cl
</pre>
<input type="button"value="hint"onClick="xb[14]^=1; zzz('x14',(xb[14])?'':
'<pre>\
shl eax,1  ;multiply value of EAX by 2 (if most sig bit=1 you get overflow)<br>\
shr ebx,cl ;divide value of EBX by 2^n, where n is the value in CL.\
</pre>'
);"><div id="x14"></div><br>


15. In x86, what does the instruction pointer (IP) register hold?
<input type="button"value="hint"onClick="xb[15]^=1; zzz('x15',(xb[15])?'':
'<pre>\
The address of the next instruction to be fetched and executed.\
</pre>'
);"><div id="x15"></div><br>


16. The unconditional jump instruction jumps to the given label. The
    conditional jump instruction jumps based on the contents of a condition
   	bit in the machine status word register. This bit is set to 0 or 1 in the
	instruction prior to the conditional jump. Explain the control flow
	instructions below assuming that each is preceeded by
	<code>cmp eax, ebx</code>:
<pre>
    jump L1 
    jle done
    je L1
    jge L1
</pre>
<input type="button"value="hint"onClick="xb[16]^=1; zzz('x16',(xb[16])?'':
'<pre>\
  jump L1  ; unconditional jump to label L1 <br>\
  jle done ; jump to label done if condition bit is -1 or 0 <br>\
  je L1    ; jump if condition bit is 0   <br>\
  jge L1   ; jump if condition bit is 0 or 1\
</pre>'
);"><div id="x16"style="height:80px"></div><br>


17. The Compare (cmp) instruction compares the values of two operands and sets
    the condition codes in the machine status word appropriately. The
    result can then be used to facilitate a jump. Explain these:
<pre>
      cmp eax, ebx   
      jle done

      cmp DWORD PTR [var], 10
      jeq loop 
</pre>
<input type="button"value="hint"onClick="xb[17]^=1; zzz('x17',(xb[17])?'':
'<pre>\
  cmp eax, ebx            ; subtract value in ebx from value in ebx; set condition bit<br>\
  jle done                ; if condition bit is -1 or 0 jump to done  <br>\
  cmp DWORD PTR [var], 10 ; subtract 10 from value at address var; set bit<br>\
  jeq loop                ; jump to loop if condition bit is 0\
</pre>'
);"><div id="x17"style="height:80px"></div><br>


18. What do the instructions below facilitate?
<pre>
    call foo
    return
</pre>
<input type="button"value="hint"onClick="xb[18]^=1; zzz('x18',(xb[18])?'':
'You call a subroutine with call and you return from a subroutine with \
return.'
);"><div id="x18"></div><br>

<!--
<input type="button"value="hint"onClick="xb[19]^=1; zzz('x19',(xb[19])?'':
);"><div id="x19"></div><br>
<input type="button"value="hint"onClick="xb[20]^=1; zzz('x20',(xb[20])?'':
);"><div id="x20"></div><br>
-->

<hr>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
